'use strict';

/**
 * Glace - A templating glaze for Redux
 * @module glace-tpl
 */
(function () {
  /**
   * An updater function for a template instance
   * @callback Updater
   * @param {Object} state new state for the template instance
   **/
  /**
   * @interface Store
   */
  /**
   * gets the current application state
   * @name Store#getState
   * @function
   * @returns the current application state
   */
  /**
   * Dispatches an action
   * @name Store#dispatch
   * @function
   * @param {Object} action action to dispatch
   **/

  /**
   * Dispatcher function for event handling
   * @callback ActionDispatcher
   * @param {Object} action An action to dispatch
   * @returns {Object} the dispatched action
   **/
  /**
   * The output of a Template
   * @typedef TemplateResult
   * @property {Array.<Node>} output List of nodes generated by the template
   * @property {Updater} update Updater function for the template instance
   **/
  /**
   * A Glace template
   * @callback Template
   * @param {Document} document the document to which the template is to be inserted
   * @param {Object} state the initial state for the template
   * @param {ActionDispatcher} dispatcher dispatcher for events
   * @returns {TemplateResult} The rendered template and an updater
   **/
  /**
   * Function to pre-load a template.
   * @callback TemplateFetcher
   * @returns {Promise.<Template, Error>} A promise that resolves to the
   *  compiled template
   **/
  /**
   * @callback FetchableTemplate
   * @param {Document} document the document to which the template is to be inserted
   * @param {Object} state the initial state for the template
   * @param {ActionDispatcher} dispatcher dispatcher for events
   * @returns {TemplateResult} The rendered template and an updater
   * @property {TemplateFetcher} fetch pre-loads a template
   **/

  /**
   * A properties object for use by a TagHandler.  Contains the values of the tag's
   *  attributes, as well as its child nodes
   * @typedef {Object} TagProperties
   * @property {Template} TEMPLATE Template function representing the tag's child nodes
   **/
  /**
   * A function that transforms a node into a template
   * @callback TagHandler
   * @param {TagProperties} props properties for the tag
   * @returns {Template} a template representing the node
   **/

  /**
   * A list of tokens for template literal substitution
   *  Even indices are raw strings
   *  Odd indices are expressions for evaluation
   * @typedef {Array.<String>} TokenList
   **/

  /**
   * Getter for a given expression against a state
   * @callback GetterFunction
   * @param {Object} state the state to get the expression from
   * @returns {*} the result
   **/

  var NIL = function NIL() {};
  var NOP = function NOP() {
    return { output: [], update: NIL };
  };
  var CONTENT_TYPE = 'text/glace-template';
  var keys = Object.keys,
      assign = Object.assign;

  var PARSERERROR = 'parsererror';
  var YIELD = '_yieldedTemplate_';
  var isArray = Array.isArray;

  /**
   * Combination of map/filter/forEach
   * @param {Array} array An array or array-Like
   * @param {Function} callback closure to execute per item
   * @returns {Array} return values of objects.  `undefined` will be filtered out.
   **/

  var collect = function collect(array, fn) {
    var len = array.length;
    var counter = 0;
    var inp = [].slice.call(array);
    var ret = [];
    for (; counter < len; counter++) {
      var result = fn(inp[counter], counter, array);
      if (result !== false) {
        ret.push(result);
      }
    }
    return ret;
  };

  // Must be written in minified ES5 for compatibility and size
  // `state` must not be mangled, as it's used internally
  var GETTER_FN = 'return function(state){try{with(state){return($)}}catch(e){return undefined}}';

  // For the Node.NODE_* constants
  var Node = {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9
  };

  /**
   * Macro for inserting a DOM node before another node.
   * @param {Node} child node before which to insert ref
   * @param {Node} ref node to insert before child
   **/
  var before = function before(child, ref) {
    ref.parentNode.insertBefore(child, ref);
  };

  /**
   * Macro for removing a DOM node.
   * @param {Node} child node to remove
   **/
  var remove = function remove(child) {
    if (child.parentNode) {
      child.parentNode.removeChild(child);
    }
  };

  /**
   * Turns a `&lt;parsererror>` node into an Error-like object
   * @class
   * @name Error
   * @param {Node} node parsererror tag from Chrome or Firefox
   * @param {String} filename source path for the failing template
   * @property {String} message Reason that parsing failed
   * @property {String} name the constant 'TemplateError'
   * @property {String} filename source path for the failing template
   * @property {Number} line line on which parsing failed
   * @property {Number} column column on which parsing failed
   * @property {String} stack Stack trace for failure
   **/
  function Error(node, filename) {
    var name = 'TemplateError';
    var error = {};
    var line = undefined;
    var col = undefined;
    var msg = undefined;
    node.textContent.replace(/ line (\d+?)| column (\d+?)|: (.*?)$/gm, function (_, _line_, _col_, _msg_) {
      line = line || _line_;
      col = col || _col_;
      msg = msg || _msg_;
    });
    assign(this, {
      message: msg,
      name: name,
      file: filename,
      line: line,
      column: col,
      stack: name + ' ' + msg + '\n\tat ' + (this.file || '<anonymous>') + ':' + line + ':' + col
    });
  }

  /**
   * Gives a node a document fragment as a parentNode if it doesn't already have one,
   * so that DOM operations can be performed on it as a sibling.
   * @param {Node} node any DOM node
   **/
  var fragParent = function fragParent(node) {
    if (!node.parentNode) {
      var f = node.ownerDocument.createDocumentFragment();
      f.appendChild(node);
    }
    return node;
  };

  /**
   * Creates a Marker - an empty text node with a parent that can be used
   *  to keep track of a View's contents.
   * @param {Document} doc the document for the marker node
   **/
  var newMarker = function newMarker(doc) {
    return fragParent(doc.createTextNode(''));
  };

  /**
   * Factory function for creating an instance of Glace
   * @param {DOMParser} PARSER an instance of DOMParser for Glace to use
   **/
  var GlaceFactory = function GlaceFactory(PARSER) {
    var TEMPLATES = {};
    var mockDoc = PARSER.parseFromString('<html><head></head><body></body></html>', 'text/html');
    var SANITIZER = mockDoc.createElement('div');

    /**
     * @name lookup
     * @function
     * @param {String} name of template
     * @returns {Template} template function for template named named `name`
     */
    var lookup = function lookup(name) {
      return TEMPLATES[name];
    };

    /**
     * Append a template to a DOM element, given a state,
     *  optionally with a dispatcher
     * If the state is a Redux-like store (supporting #getState and #dispatch),
     *  will automatically subscribe to the store.
     * @function
     * @name append
     * @param {Node} element to append template to
     * @param {Template} template to append
     * @param {Object} state initial state for the template
     * @param {Store|ActionDispatcher} dispatcher for handling events
     * @returns {Updater} update function for this template instance
     **/
    var append = function append(parentNode, childTemplate, state, dispatch) {
      if (typeof childTemplate === 'string') {
        childTemplate = exports(childTemplate);
      }
      var doc = parentNode.ownerDocument;
      var store = null;
      if (state && state.getState && state.subscribe) {
        // This is a redux-like store; handle it autmatically
        store = state;
        dispatch = store.dispatch;
        state = store.getState();
      }
      var rendered = childTemplate(doc, state, dispatch);
      collect(rendered.output, function (child) {
        parentNode.appendChild(child);
      });
      if (store) {
        var stale = false;
        store.subscribe(function () {
          if (!stale) {
            stale = true;
            requestAnimationFrame(function (_) {
              rendered.update(store.getState());
              stale = false;
            });
          }
        });
      }
      return rendered.update;
    };

    /**
     * HTML escapes a string
     * @private
     * @param {String} str the string to escape
     * @returns {String} the escaped string
     **/
    var sanitize = function sanitize(str) {
      SANITIZER.textContent = str;
      return SANITIZER.innerHTML;
    };

    /**
     * Returns a template function that behaves like an `if` statement.
     *  The limitations of XML markup mean that we can't have an `else`
     *  clause.
     * @private
     * @param {Template} trueTemplate template to display if condition is true
     * @param {Template} falseTemplate template to display if condition is false
     * @param {String} condition to be evaluated
     * @returns {Template} wrapper for the conditional templates.
     **/
    var condition = function condition(trueTemplate, falseTemplate, _condition) {
      trueTemplate = trueTemplate || NOP;
      falseTemplate = falseTemplate || NOP;
      var getCondition = getter(_condition);
      return function (doc, state, dispatch) {
        var ins = NOP();
        var marker = newMarker(doc);
        var value = undefined;
        var update = function update(newState) {
          // Object's removed, but updater's being called;
          //  return to init state
          if (!marker.parentNode) {
            ins = NOP();
            value = undefined;
            return;
          }
          var newValue = !!getCondition(newState);
          if (newValue !== value) {
            value = newValue;
            collect(ins.output, function (node) {
              return remove(node);
            });
            ins = newValue ? trueTemplate(doc, newState, dispatch) : falseTemplate(doc, newState, dispatch);
            collect(ins.output, function (node) {
              return before(node, marker);
            });
          } else {
            ins.update(newState);
          }
        };
        update(state);
        return {
          output: [].slice.call(marker.parentNode.childNodes),
          update: update
        };
      };
    };

    /**
     * Returns a template function that inlines another template
     *  based on `expression`, with an inner template that can be
     *  further transcluded using <yield />
     * @private
     * @param {Template} yieldTemplate the template that can be yielded to,
     *        usually the children of the tag that caused the transclusion.
     * @param {Template} template the template to transclude
     * @param {String} state An expression to evaluate for the transclusion's state
     * @returns {Template} the combined template
     **/
    var transclude = function transclude(yieldTemplate, template, state) {
      var getTemplate = getter(template);
      var getChildState = state ? getter(state) : function (newState) {
        return newState;
      };
      var adjustState = function adjustState(state) {
        var localState = assign({}, state);
        localState[YIELD] = yieldTemplate;
        return localState;
      };
      return function (doc, state, dispatch) {
        var marker = newMarker(doc);
        var template = undefined;
        var ins = { output: [], update: function update() {} };
        var update = function update(newState) {
          newState = adjustState(getChildState(newState));
          var newTemplate = getTemplate(newState) || NOP;
          if (newTemplate !== template) {
            template = newTemplate;
            if (typeof template === 'string') {
              template = exports(template);
            }
            collect(ins.output, function (child) {
              return remove(child);
            });
            ins = template(doc, newState, dispatch);
            collect(ins.output, function (child) {
              return before(child, marker);
            });
          } else {
            ins.update(newState);
          }
        };
        update(state);
        return {
          output: [].slice.call(ins.output).concat([marker]),
          update: update
        };
      };
    };
    /**
     * Returns a template that renders a list, using an instance of
     *  `templateForEach` for each item.
     * Default names for the content item and index are `content` and
     *  `index`, but can be overridden in the <for> helper using the
     *  attributes `as` and `index`
     * @private
     * @param {Template} templateForEach the template to render for each item in the list
     * @param {String} expression evaluates to the list to iterate over
     * @param {String} asName name in the state for the items to have
     * @param {String} indexName name in the state for indices to have
     * @returns {Template} the template for the for loop
     **/
    var list = function list(templateForEach, expression, asName, indexName) {
      var getList = getter(expression);
      var list = [];
      var ins = [];
      asName = asName || 'content';
      indexName = indexName || 'index';
      var makeState = function makeState(newState, index, value) {
        var obj = { parent: newState };
        obj[asName] = value;
        obj[indexName] = index;
        return obj;
      };
      return function (doc, state, dispatch) {
        var marker = newMarker(doc);
        var update = function update(newState) {
          if (!marker.parentNode) {
            list = [];
            ins = [];
            return;
          }
          var newList = void 0;
          newList = getList(newState) || [];
          var len = Math.max(list.length, newList.length);
          var parentNode = marker.parentNode;

          var _loop = function _loop(i) {
            var cpos = ins[i + 1] && ins[i + 1].output[0] || marker;
            // Present in both places
            if (list[i] && newList[i]) {
              if (list[i] !== newList[i]) {
                ins[i].update(makeState(newState, i, newList[i]));
              }
            } else if (list[i] && !newList[i]) {
              collect(ins[i].output, function (child) {
                return remove(child);
              });
              ins[i] = null;
            } else if (!list[i] && newList[i]) {
              ins[i] = templateForEach(doc, makeState(newState, i, newList[i]), dispatch);
              collect(ins[i].output, function (child) {
                return before(child, cpos);
              });
            }
          };

          for (var i = 0; i < len; i += 1) {
            _loop(i);
          }
          ins.length = newList.length;
          list = newList;
        };
        update(state);
        return {
          output: [].slice.call(marker.parentNode.childNodes),
          update: update
        };
      };
    };

    /**
     * Tokenizer for template literals.  These are JS-style, e.g.,
     *  `text text text ${expression} text text text`.
     * @private
     * @param {String} s a string to parse for template literals
     * @returns {TokenList} the list of tokens
     **/
    var tokenizeLiterals = function tokenizeLiterals(s) {
      var tokens = [];
      var state = void 0;
      var cur = [];
      var depth = 0;
      state = 0;
      for (var i = 0; i < s.length; i += 1) {
        if (s[i] === '\\' && s[i + 1] === '$' || s[i + 1] === '\\') {
          cur.push(s[i + 1]);
          i += 1;
          continue;
        }
        if (state === 0) {
          if (s[i] === '$' && s[i + 1] === '{') {
            state = 1;
            i += 1;
            depth = 1;
            tokens.push(cur.join(''));
            cur = [];
            continue;
          }
        }
        if (state === 1) {
          if (s[i] === '{') {
            depth += 1;
            cur.push(s[i]);
            continue;
          }
          if (s[i] === '}') {
            depth -= 1;
            if (depth === 0) {
              state = 0;
              tokens.push(cur.join(''));
              cur = [];
              continue;
            }
          }
        }
        cur.push(s[i]);
      }
      if (state === 1) {
        throw new Error("Unclosed template literal: " + s);
      }
      if (cur.length) {
        tokens.push(cur.join(''));
      }
      return tokens;
    };

    /**
     * Creates a sandboxed getter function for a property described by
     *  `expression`.  The getter function accepts the `state` as its
     *  argument.
     *  The expression has access to a set of injected methods; at the moment,
     *  that set is just `sanitize`.
     * @param {String} expression An expression to get relative to the state
     * @returns {GetterFunction} The getter function for this expression.
     **/
    var getter = function getter(expression) {
      var body = GETTER_FN.replace(/\$/g, expression);
      var fn = new Function(
      // List of injected keywords
      'sanitize', body)(
      // list of injected values
      sanitize);
      fn.expression = expression;
      return fn;
    };
    /**
     * Return a template that is the concatenation of a number of templates
     * @param {Array.<Template>} templates a list of templates to concatenate
     * @returns {Template} the concatenated templates
     **/
    var concatenate = function concatenate(templates) {
      templates = templates.map(function (tpl) {
        if (typeof tpl === 'string') {
          return compile(tpl);
        }
        if (isArray(tpl)) {
          return concatenate(tpl);
        }
        return tpl;
      });
      return function (d, s, dispatch) {
        var nodes = [];
        var updaters = [];
        collect(templates, function (template) {
          var handle = template(d, s, dispatch);
          nodes = nodes.concat(handle.output);
          updaters.push(handle.update);
        });
        return {
          output: nodes,
          update: function update(newState) {
            collect(updaters, function (updater) {
              return updater(newState);
            });
          }
        };
      };
    };

    /**
     * Create an array of template functions from a DOM tree.  This is the
     *  meat of `compile`.
     * @param {Array.<Node>} nodes a list of nodes
     * @param {String} filename path to the template the nodes came from
     * @returns {Array.<Template>} a list of templates matching the passed nodes
     **/
    var makeDOMGenerators = function makeDOMGenerators(nodes, filename) {
      var generators = [];
      collect(nodes, function (node) {
        // Ignored (normally because should never see)
        //  COMMENT_NODE <- intentionally ignored
        //  PROCESSING_INSTRUCTION_NODE <- intentionally ignored
        //  CDATA_SECTION_NODE <- should handle these
        //  DOCUMENT_NODE
        //  DOCUMENT_FRAGMENT_NODE
        //  DOCUMENT_TYPE_NODE
        //  ENTITY_NODE
        //  ENTITY_REFERENCE_NODE
        //  NOTATION_NODE
        //  ATTRIBUTE_NODE
        if (node.nodeType === Node.TEXT_NODE) {
          return collect(tokenizeLiterals(node.textContent), function (t, i) {
            var isText = i % 2 === 0;
            if (!t) {
              return;
            }
            if (isText) {
              generators.push(function (d, s) {
                return {
                  output: [d.createTextNode(t)],
                  update: NIL
                };
              });
            } else {
              var getValue = getter(t);
              generators.push(function (d, s) {
                var n = d.createTextNode(getValue(s));
                return {
                  output: [n],
                  update: function update(newState) {
                    n.textContent = getValue(newState);
                  }
                };
              });
            }
          });
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          var tagName = node.tagName;
          var lcTag = tagName.toLowerCase();
          if (exports.tagHandlers[lcTag]) {
            generators.push(callTagHandler(lcTag, node));
            return;
          }
          var childGenerators = makeDOMGenerators([].slice.call(node.childNodes));
          var attributes = [];
          var events = [];
          collect(node.attributes, function (att) {
            if (att.nodeName.substr(0, 3) === 'on-') {
              events.push({
                name: att.nodeName.substr(3),
                action: new Function('event', 'state', 'dispatch', 'with(state){\n' + att.nodeValue + '\n}')
              });
            } else {
              attributes.push({
                name: att.nodeName,
                value: tokenizeLiterals(att.nodeValue).map(function (att, i) {
                  if (i % 2 === 0) {
                    return att;
                  } else {
                    return getter(att);
                  }
                })
              });
            }
          });
          generators.push(function (d, s, dispatch) {
            var el = d.createElement(tagName);
            collect(events, function (handler) {
              el.addEventListener(handler.name, function (event) {
                return handler.action.call(event.target, event, currentState, dispatch);
              }, false);
            });

            var updaters = [];
            collect(childGenerators, function (gen) {
              var child = gen(d, s, dispatch);
              updaters.push(child.update);
              collect(child.output, function (childNode) {
                el.appendChild(childNode);
              });
            });
            var currentState = s;
            var update = function update(newState) {
              currentState = newState;
              collect(attributes, function (att) {
                if (attributeHandlers[att.name]) {
                  attributeHandlers[att.name](newState, el, att.value);
                } else {
                  el.setAttribute(att.name, att.value.map(function (token) {
                    if (token instanceof Function) {
                      return token(newState);
                    } else {
                      return token;
                    }
                  }).join(''));
                }
              });
              collect(updaters, function (updater) {
                return updater(newState);
              });
            };
            update(s);
            return {
              output: [el],
              update: update
            };
          });
        }
      });
      return generators;
    };
    /**
     * Rolls a tag's attributes and content into a properties object, and calls
     *  the relevant tagHandler
     * @param {String} tagName normalized tagname of the node
     * @param {Node} node the node
     * @returns {Template} the resultant template for the node
     **/
    var callTagHandler = function callTagHandler(tagName, node) {
      var properties = {};
      collect(node.attributes, function (attribute) {
        properties[attribute.nodeName] = attribute.nodeValue;
      });
      properties.TEMPLATE = concatenate(makeDOMGenerators(nodeList));
      return exports.tagHandlers[tagName](properties);
    };
    /**
     * Custom template generators for tags
     **/
    var tagHandlers = {
      /**
       * Does not render the child nodes unless `expression` is true
       * Example: <if cond="expression">...</if>
       * @implements {TagHandler}
       **/
      'if': function _if(props) {
        return condition(props.TEMPLATE, null, props.cond);
      },
      /**
       * Does not render the child nodes unless `expression` is false
       * Example: <unless cond="expression">...</unless>
       * @implements {TagHandler}
       **/
      'unless': function unless(props) {
        return condition(null, props.TEMPLATE, props.cond);
      },
      /**
       * Returns a template that renders either the template referenced by `from` or the
       *  list of child nodes for each of the object referenced by `each`
       *  Example: <for each="expression"
       *             [as="name"]
       *             [index="name"]
       *             [from="expression"]>
       *             ...
       *           </for>
       * @implements {TagHandler}
       **/
      'for': function _for(props) {
        return list(props.template || props.TEMPLATE, props.each, props.as, props.index);
      },
      /**
       * Returns a template that pulls in a template as referenced by `expression`,
       *  providing the child template to `yield`
       *  e.g., <view template="expression" state="expression">...</view>
       * @implements {TagHandler}
       **/
      'view': function view(props) {
        return transclude(props.TEMPLATE, props.template, props.state);
      },
      /**
       * <yield />
       *  Renders the child template as passed from `view`
       * @implements {TagHandler}
       **/
      'yield': function _yield(props) {
        return function (doc, state, dispatch) {
          var childState = assign({}, state);
          delete childState[YIELD];
          return state[YIELD](doc, childState, dispatch);
        };
      }
    };
    /**
     * Utility function for flag-like attributes
     * @private
     * @param {TokenList} value list of tokens for substitution
     * @param {Object} state state from which to pull substitutions
     * @returns evaluated attribute value
     **/
    var flagList = function flagList(value, state) {
      return value.map(function (v, i) {
        if (i % 2 === 0) {
          return v;
        } else {
          var r = v(state);
          if (r === true) {
            return v.expression.replace(/^[^\.]*\./, '');
          }
          if (!r) {
            return '';
          }
          return r;
        }
      }).join('').trim();
    };
    /**
     * Runtime handlers for attributes
     * TODO: This should be handleable at compile-time.
     * @private
     **/
    var attributeHandlers = {
      /**
       * handler for `@class`; casts boolean evaluation results
       *  as their expression
       **/
      'class': function _class(state, element, value) {
        element.className = flagList(value, state);
      }
    };
    /**
     * Create a tag handler from a template and a list of property names
     * @name handler
     * @function
     * @param {String} name tag name to override with this template
     * @param {Array.<String>} propNames the list of property names to add to the handler's `props`
     * @param {Template} template a template to use for this tag
     **/
    var handler = function handler(name, propNames, template) {
      var tpl = template;
      if (typeof tpl === 'string') {
        tpl = compile(template);
      }
      if (isArray(tpl)) {
        tpl = concatenate(tpl);
      }
      exports.tagHandlers[name] = function (props) {
        var getters = propNames.reduce(function (g, p) {
          g[p] = getter(props[p]);
          return g;
        }, {});
        var adjustState = function adjustState(state) {
          var localState = assign({}, state);
          collect(keys(getters), function (p) {
            localState[p] = getters[p](state);
          });
          return localState;
        };
        return function (doc, state, dispatch) {
          var ret = tpl(doc, adjustState(state), dispatch);
          ret.update = adjustUpdate(ret.update, adjustState);
          return ret;
        };
      };
    };
    /**
     * Utility function for injecting an adjustment in state.
     *  adjust SHOULD NOT mutate state, but return a new object
     * @private
     * @param {Function} update function to update the template
     * @param {Object} adjust function to adjust the state
     **/
    var adjustUpdate = function adjustUpdate(update, adjust) {
      (function (state) {
        update(adjust(state));
      });
    };
    /**
     * Compile a template, optionally with filename if known
     * @method compile
     * @param {String} tpl A template string
     * @param {String} filename path to the source of the template
     * @returns {Template} the compiled template
     **/
    var compile = function compile(tpl, filename) {
      var dom = PARSER.parseFromString('<G>' + tpl + '</G>', 'text/xml');
      var err = dom.getElementsByTagName(PARSERERROR)[0];
      if (err) {
        throw new TemplateError(dom.querySelector(PARSERERROR + '>div'), filename);
      }
      var generators = makeDOMGenerators([].slice.call(dom.childNodes[0].childNodes));
      return concatenate(generators);
    };
    /**
     * Add an asynchronous template to the registry
     * @name fetch
     * @function
     * @param {String} url  path on server of the template
     * @param {String} loadingClass classname for placeholder div; default=glace-loading
     * @return {FetchableTemplate} the compiled template function.
     **/
    var fetchTemplate = function fetchTemplate(url, loadingClass) {
      // For async templates, leave a marker, then
      //  transclude in when resolved.
      var realTemplate = void 0;
      var promise = null;
      var grab = function grab() {
        promise = fetch(url).then(function (response) {
          return response.text();
        }).then(function (text) {
          return compile(text, url);
        });
        return promise;
      };
      template = function template(d, s, dispatch) {
        if (realTemplate) {
          return realTemplate(d, s, dispatch);
        }
        if (!promise) grab();
        var marker = fragParent(assign(d.createElement('div'), {
          className: loadingClass || 'glace-loading'
        }));
        var output = [marker];
        var currentState = s;
        var _update = function update(newState) {
          currentState = newState;
        };
        promise.then(function (realTemplate) {
          var rendered = realTemplate(d, currentState, dispatch);
          _update = rendered.update;
          collect(rendered.output, function (child) {
            before(child, marker);
            output.push(child);
          });
          output.shift();
          remove(marker);
        });
        return {
          output: output,
          update: function update(newState) {
            return _update(newState);
          }
        };
      };
      template.fetch = grab;
      return template;
    };
    /**
     * Register a template in the Glace registry, making it available
     * for the `&lt;view>` tag
     * @name register
     * @function
     * @param {String} id unique ID for this template
     * @param {String} props comma-delimited list of property names
     * @param {Template} fn template function
     **/
    var registerTemplate = function registerTemplate(id, props, fn) {
      var template = void 0;
      if (TEMPLATES[id]) {
        template = TEMPLATES[id];
      } else {
        template = fn();
      }
      if (props) {
        props = props.split(',').map(function (name) {
          return name.trim();
        });
        handler(id, props, template);
      }
      TEMPLATES[id] = template;
    };
    return {
      append: append,
      compile: compile,
      fetch: fetchTemplate,
      handler: handler,
      lookup: lookup,
      register: registerTemplate,
      tagHandlers: tagHandlers,
      Error: TemplateError
    };
  };
  (function () {
    try {
      try {
        define("Glace", function () {
          return GlaceFactory;
        });
      } catch (e) {
        module.exports = GlaceFactory;
      }
    } catch (f) {
      var Glace = window.Glace = GlaceFactory(new DOMParser());
      // Read all the template references off the page.
      //  If a `props` attribute is present, make it a handler.
      collect(document.querySelectorAll('script[id][type="' + CONTENT_TYPE + '"]'), function (el) {
        Glace.registerTemplate(scr.id, scr.getAttribute('props'), function () {
          return Glace.compile(scr.textContent, '#' + scr.id);
        });
      });
      collect(document.querySelectorAll('meta[glace-template]'), function (meta) {
        var url = meta.getAttribute('glace-template');
        var id = url.replace(/^.*\/|\.tpl$/g, '');
        Glace.registerTemplate(id, meta.getAttribute('props'), function () {
          return Glace.fetchTemplate(url, meta.getAttribute('loading-class'));
        });
      });
    }
  })();
})();
